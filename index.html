<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TETRIS</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #0a0a0f;
            --panel: #11111a;
            --border: #2a2a4a;
            --glow-cyan: #00ffff;
            --glow-pink: #ff00aa;
            --glow-yellow: #ffee00;
            --text: #e0e0ff;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: var(--bg);
            font-family: 'Press Start 2P', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            color: var(--text);
        }

        body::before {
            content: '';
            position: fixed;
            inset: 0;
            background:
                radial-gradient(ellipse at 20% 50%, rgba(0, 255, 255, 0.04) 0%, transparent 60%),
                radial-gradient(ellipse at 80% 50%, rgba(255, 0, 170, 0.04) 0%, transparent 60%);
            pointer-events: none;
        }

        /* CRT scanlines */
        body::after {
            content: '';
            position: fixed;
            inset: 0;
            background: repeating-linear-gradient(0deg,
                    transparent,
                    transparent 2px,
                    rgba(0, 0, 0, 0.08) 2px,
                    rgba(0, 0, 0, 0.08) 4px);
            pointer-events: none;
            z-index: 999;
        }

        .container {
            display: flex;
            gap: 24px;
            align-items: flex-start;
            padding: 20px;
        }

        .side-panel {
            width: 160px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .panel-box {
            border: 2px solid var(--border);
            background: var(--panel);
            padding: 16px;
            position: relative;
        }

        .panel-box::before {
            content: '';
            position: absolute;
            inset: -1px;
            border: 1px solid rgba(0, 255, 255, 0.1);
            pointer-events: none;
        }

        .panel-label {
            font-size: 6px;
            color: var(--glow-cyan);
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-bottom: 12px;
            text-shadow: 0 0 8px var(--glow-cyan);
        }

        .panel-value {
            font-size: 12px;
            color: var(--glow-yellow);
            text-shadow: 0 0 12px var(--glow-yellow);
            word-break: break-all;
        }

        #next-canvas {
            display: block;
            image-rendering: pixelated;
        }

        /* Main game board */
        .game-wrapper {
            position: relative;
        }

        .game-border {
            border: 3px solid var(--border);
            padding: 3px;
            background: var(--panel);
            box-shadow:
                0 0 40px rgba(0, 255, 255, 0.08),
                inset 0 0 20px rgba(0, 0, 0, 0.5);
            position: relative;
        }

        .game-border::before,
        .game-border::after {
            content: '';
            position: absolute;
            width: 12px;
            height: 12px;
            border-color: var(--glow-cyan);
            border-style: solid;
            box-shadow: 0 0 8px var(--glow-cyan);
        }

        .game-border::before {
            top: -1px;
            left: -1px;
            border-width: 2px 0 0 2px;
        }

        .game-border::after {
            bottom: -1px;
            right: -1px;
            border-width: 0 2px 2px 0;
        }

        #game-canvas {
            display: block;
            image-rendering: pixelated;
        }

        /* Title */
        .title {
            text-align: center;
            font-size: 28px;
            letter-spacing: 8px;
            margin-bottom: 4px;
            background: linear-gradient(90deg, var(--glow-cyan), var(--glow-pink), var(--glow-yellow));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            filter: drop-shadow(0 0 20px rgba(0, 255, 255, 0.5));
            animation: titlePulse 3s ease-in-out infinite;
        }

        @keyframes titlePulse {

            0%,
            100% {
                filter: drop-shadow(0 0 20px rgba(0, 255, 255, 0.5));
            }

            50% {
                filter: drop-shadow(0 0 30px rgba(255, 0, 170, 0.6));
            }
        }

        .subtitle {
            font-size: 5px;
            text-align: center;
            color: rgba(255, 255, 255, 0.3);
            letter-spacing: 4px;
            margin-bottom: 20px;
        }

        /* Overlay */
        #overlay {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(10, 10, 15, 0.88);
            z-index: 10;
            gap: 20px;
        }

        #overlay h2 {
            font-size: 14px;
            color: var(--glow-cyan);
            text-shadow: 0 0 20px var(--glow-cyan);
            text-align: center;
            line-height: 2;
            animation: blink 1s step-end infinite;
        }

        @keyframes blink {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.2;
            }
        }

        #overlay p {
            font-size: 7px;
            color: rgba(255, 255, 255, 0.4);
            text-align: center;
            line-height: 2;
            letter-spacing: 1px;
        }

        .start-btn {
            background: none;
            border: 2px solid var(--glow-pink);
            color: var(--glow-pink);
            font-family: 'Press Start 2P', monospace;
            font-size: 9px;
            padding: 12px 24px;
            cursor: pointer;
            letter-spacing: 2px;
            text-shadow: 0 0 10px var(--glow-pink);
            box-shadow: 0 0 20px rgba(255, 0, 170, 0.3);
            transition: all 0.2s;
        }

        .start-btn:hover {
            background: rgba(255, 0, 170, 0.1);
            box-shadow: 0 0 30px rgba(255, 0, 170, 0.5);
            transform: scale(1.05);
        }

        .controls {
            font-size: 5px;
            color: rgba(255, 255, 255, 0.25);
            text-align: center;
            line-height: 2.5;
            margin-top: 8px;
        }

        .level-bar-container {
            height: 6px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border);
            margin-top: 8px;
            overflow: hidden;
        }

        #level-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--glow-cyan), var(--glow-pink));
            box-shadow: 0 0 8px var(--glow-cyan);
            transition: width 0.3s;
        }
    </style>
</head>

<body>

    <div class="container">
        <!-- Left panel -->
        <div class="side-panel">
            <div class="panel-box">
                <div class="panel-label">SCORE</div>
                <div class="panel-value" id="score-display">0</div>
            </div>
            <div class="panel-box">
                <div class="panel-label">LEVEL</div>
                <div class="panel-value" id="level-display">1</div>
                <div class="level-bar-container">
                    <div id="level-bar"></div>
                </div>
            </div>
            <div class="panel-box">
                <div class="panel-label">LINES</div>
                <div class="panel-value" id="lines-display">0</div>
            </div>
            <div class="panel-box">
                <div class="panel-label">HIGH</div>
                <div class="panel-value" id="high-display">0</div>
            </div>
        </div>

        <!-- Center game -->
        <div>
            <div class="title">TETRIS</div>
            <div class="subtitle">ARCADE EDITION</div>
            <div class="game-wrapper">
                <div class="game-border">
                    <canvas id="game-canvas" width="300" height="600"></canvas>
                </div>
                <div id="overlay">
                    <h2>TETRIS</h2>
                    <p>A ← → 이동<br>↑ 회전<br>↓ 빠르게<br>SPACE 즉시 낙하<br>P 일시정지</p>
                    <button class="start-btn" id="start-btn">START GAME</button>
                </div>
            </div>
        </div>

        <!-- Right panel -->
        <div class="side-panel">
            <div class="panel-box">
                <div class="panel-label">NEXT</div>
                <canvas id="next-canvas" width="120" height="120"></canvas>
            </div>
            <div class="panel-box">
                <div class="panel-label">COMBO</div>
                <div class="panel-value" id="combo-display">0x</div>
            </div>
            <div class="controls">
                ←→ MOVE<br>
                ↑ ROTATE<br>
                ↓ SOFT DROP<br>
                SPACE HARD DROP<br>
                P PAUSE
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const nextCanvas = document.getElementById('next-canvas');
        const nextCtx = nextCanvas.getContext('2d');

        const COLS = 10, ROWS = 20, BLOCK = 30;
        const COLORS = [
            null,
            ['#00ffff', '#00cccc'], // I - cyan
            ['#ffff00', '#cccc00'], // O - yellow
            ['#aa00ff', '#8800cc'], // T - purple
            ['#00ff44', '#00cc33'], // S - green
            ['#ff2244', '#cc1133'], // Z - red
            ['#0088ff', '#0066cc'], // J - blue
            ['#ff8800', '#cc6600'], // L - orange
        ];

        const PIECES = [
            null,
            [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]], // I
            [[2, 2], [2, 2]],                               // O
            [[0, 3, 0], [3, 3, 3], [0, 0, 0]],                   // T
            [[0, 4, 4], [4, 4, 0], [0, 0, 0]],                   // S
            [[5, 5, 0], [0, 5, 5], [0, 0, 0]],                   // Z
            [[6, 0, 0], [6, 6, 6], [0, 0, 0]],                   // J
            [[0, 0, 7], [7, 7, 7], [0, 0, 0]],                   // L
        ];

        let board, piece, pieceX, pieceY, pieceType, nextType;
        let score, level, lines, combo, highScore = 0;
        let gameOver = false, paused = false, running = false;
        let dropInterval, lastDrop = 0;
        let animFrame;
        let flashRows = [];
        let flashTimer = 0;

        function createBoard() {
            return Array.from({ length: ROWS }, () => Array(COLS).fill(0));
        }

        function randomPiece() {
            return Math.floor(Math.random() * 7) + 1;
        }

        function startGame() {
            board = createBoard();
            score = 0; level = 1; lines = 0; combo = 0;
            gameOver = false; paused = false;
            nextType = randomPiece();
            spawnPiece();
            updateUI();
            document.getElementById('overlay').style.display = 'none';
            running = true;
            lastDrop = performance.now();
            if (animFrame) cancelAnimationFrame(animFrame);
            gameLoop(performance.now());
        }

        function spawnPiece() {
            pieceType = nextType;
            nextType = randomPiece();
            piece = PIECES[pieceType].map(r => [...r]);
            pieceX = Math.floor((COLS - piece[0].length) / 2);
            pieceY = 0;
            if (collides(piece, pieceX, pieceY)) {
                endGame();
            }
        }

        function collides(p, px, py) {
            for (let r = 0; r < p.length; r++)
                for (let c = 0; c < p[r].length; c++)
                    if (p[r][c]) {
                        let nx = px + c, ny = py + r;
                        if (nx < 0 || nx >= COLS || ny >= ROWS) return true;
                        if (ny >= 0 && board[ny][nx]) return true;
                    }
            return false;
        }

        function rotate(p) {
            const rows = p.length, cols = p[0].length;
            const rot = Array.from({ length: cols }, () => Array(rows).fill(0));
            for (let r = 0; r < rows; r++)
                for (let c = 0; c < cols; c++)
                    rot[c][rows - 1 - r] = p[r][c];
            return rot;
        }

        function lockPiece() {
            for (let r = 0; r < piece.length; r++)
                for (let c = 0; c < piece[r].length; c++)
                    if (piece[r][c] && pieceY + r >= 0)
                        board[pieceY + r][pieceX + c] = pieceType;
            clearLines();
            spawnPiece();
            drawNext();
        }

        function clearLines() {
            let cleared = 0;
            let toRemove = [];
            for (let r = ROWS - 1; r >= 0; r--) {
                if (board[r].every(c => c !== 0)) {
                    toRemove.push(r);
                    cleared++;
                }
            }
            if (cleared > 0) {
                flashRows = toRemove;
                flashTimer = 8;
                combo++;
                const pts = [0, 100, 300, 500, 800][cleared] * level;
                const comboBonus = combo > 1 ? (combo - 1) * 50 * level : 0;
                score += pts + comboBonus;
                lines += cleared;
                level = Math.floor(lines / 10) + 1;
                if (score > highScore) highScore = score;
            } else {
                combo = 0;
                actualClearLines([]);
            }
            updateUI();
        }

        function actualClearLines(toRemove) {
            if (toRemove.length === 0 && flashRows.length === 0) return;
            const rows = flashRows.length > 0 ? flashRows : toRemove;
            rows.sort((a, b) => a - b);
            for (let i = rows.length - 1; i >= 0; i--) {
                board.splice(rows[i], 1);
                board.unshift(Array(COLS).fill(0));
            }
            flashRows = [];
        }

        function getDropSpeed() {
            return Math.max(50, 800 - (level - 1) * 70);
        }

        function gameLoop(ts) {
            if (!running) return;
            if (!paused && !gameOver) {
                if (flashTimer > 0) {
                    flashTimer--;
                    if (flashTimer === 0) actualClearLines(flashRows);
                } else {
                    if (ts - lastDrop > getDropSpeed()) {
                        if (!collides(piece, pieceX, pieceY + 1)) {
                            pieceY++;
                        } else {
                            lockPiece();
                        }
                        lastDrop = ts;
                    }
                }
                draw();
            }
            animFrame = requestAnimationFrame(gameLoop);
        }

        function getGhostY() {
            let gy = pieceY;
            while (!collides(piece, pieceX, gy + 1)) gy++;
            return gy;
        }

        function draw() {
            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Grid lines
            ctx.strokeStyle = 'rgba(255,255,255,0.03)';
            ctx.lineWidth = 0.5;
            for (let c = 0; c <= COLS; c++) {
                ctx.beginPath(); ctx.moveTo(c * BLOCK, 0); ctx.lineTo(c * BLOCK, canvas.height); ctx.stroke();
            }
            for (let r = 0; r <= ROWS; r++) {
                ctx.beginPath(); ctx.moveTo(0, r * BLOCK); ctx.lineTo(canvas.width, r * BLOCK); ctx.stroke();
            }

            // Board
            for (let r = 0; r < ROWS; r++) {
                const isFlash = flashRows.includes(r);
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c]) {
                        if (isFlash) {
                            const t = flashTimer / 8;
                            ctx.fillStyle = t > 0.5 ? '#ffffff' : COLORS[board[r][c]][0];
                            ctx.fillRect(c * BLOCK, r * BLOCK, BLOCK, BLOCK);
                            ctx.fillStyle = 'rgba(255,255,255,0.5)';
                            ctx.fillRect(c * BLOCK, r * BLOCK, BLOCK, BLOCK);
                        } else {
                            drawBlock(ctx, c * BLOCK, r * BLOCK, COLORS[board[r][c]][0], COLORS[board[r][c]][1]);
                        }
                    }
                }
            }

            // Ghost
            if (!gameOver) {
                const gy = getGhostY();
                ctx.globalAlpha = 0.18;
                for (let r = 0; r < piece.length; r++)
                    for (let c = 0; c < piece[r].length; c++)
                        if (piece[r][c]) {
                            ctx.fillStyle = COLORS[pieceType][0];
                            ctx.fillRect((pieceX + c) * BLOCK + 1, (gy + r) * BLOCK + 1, BLOCK - 2, BLOCK - 2);
                        }
                ctx.globalAlpha = 1;
            }

            // Current piece
            if (!gameOver && piece) {
                for (let r = 0; r < piece.length; r++)
                    for (let c = 0; c < piece[r].length; c++)
                        if (piece[r][c])
                            drawBlock(ctx, (pieceX + c) * BLOCK, (pieceY + r) * BLOCK, COLORS[pieceType][0], COLORS[pieceType][1]);
            }
        }

        function drawBlock(c, x, y, color, shadow) {
            c.fillStyle = color;
            c.fillRect(x + 1, y + 1, BLOCK - 2, BLOCK - 2);
            // Highlight
            c.fillStyle = 'rgba(255,255,255,0.25)';
            c.fillRect(x + 1, y + 1, BLOCK - 2, 4);
            c.fillRect(x + 1, y + 1, 4, BLOCK - 2);
            // Shadow
            c.fillStyle = 'rgba(0,0,0,0.3)';
            c.fillRect(x + BLOCK - 5, y + 1, 4, BLOCK - 2);
            c.fillRect(x + 1, y + BLOCK - 5, BLOCK - 2, 4);
            // Glow
            c.strokeStyle = color;
            c.globalAlpha = 0.4;
            c.lineWidth = 1;
            c.strokeRect(x, y, BLOCK, BLOCK);
            c.globalAlpha = 1;
        }

        function drawNext() {
            nextCtx.fillStyle = '#11111a';
            nextCtx.fillRect(0, 0, 120, 120);
            const p = PIECES[nextType];
            const offX = Math.floor((4 - p[0].length) / 2);
            const offY = Math.floor((4 - p.length) / 2);
            const bs = 24;
            for (let r = 0; r < p.length; r++)
                for (let c = 0; c < p[r].length; c++)
                    if (p[r][c])
                        drawBlock(nextCtx, (offX + c) * bs + 12, (offY + r) * bs + 12, COLORS[nextType][0], COLORS[nextType][1]);
        }

        function updateUI() {
            document.getElementById('score-display').textContent = score;
            document.getElementById('level-display').textContent = level;
            document.getElementById('lines-display').textContent = lines;
            document.getElementById('high-display').textContent = highScore;
            document.getElementById('combo-display').textContent = combo + 'x';
            const progress = (lines % 10) / 10 * 100;
            document.getElementById('level-bar').style.width = progress + '%';
        }

        function endGame() {
            gameOver = true;
            running = false;
            if (score > highScore) highScore = score;
            const overlay = document.getElementById('overlay');
            overlay.style.display = 'flex';
            overlay.innerHTML = `
    <h2>GAME OVER</h2>
    <p>SCORE: ${score}<br>LEVEL: ${level}<br>LINES: ${lines}</p>
    <button class="start-btn" id="start-btn" onclick="startGame()">RETRY</button>
  `;
        }

        // Controls
        document.addEventListener('keydown', e => {
            if (!running || gameOver) return;
            if (e.key === 'p' || e.key === 'P') {
                paused = !paused;
                if (!paused) { lastDrop = performance.now(); gameLoop(lastDrop); }
                return;
            }
            if (paused) return;
            switch (e.key) {
                case 'ArrowLeft':
                    e.preventDefault();
                    if (!collides(piece, pieceX - 1, pieceY)) pieceX--;
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    if (!collides(piece, pieceX + 1, pieceY)) pieceX++;
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    if (!collides(piece, pieceX, pieceY + 1)) { pieceY++; score += 1; }
                    else lockPiece();
                    lastDrop = performance.now();
                    break;
                case 'ArrowUp':
                    e.preventDefault();
                    const rot = rotate(piece);
                    if (!collides(rot, pieceX, pieceY)) piece = rot;
                    else if (!collides(rot, pieceX + 1, pieceY)) { piece = rot; pieceX++; }
                    else if (!collides(rot, pieceX - 1, pieceY)) { piece = rot; pieceX--; }
                    break;
                case ' ':
                    e.preventDefault();
                    const gy = getGhostY();
                    score += (gy - pieceY) * 2;
                    pieceY = gy;
                    lockPiece();
                    lastDrop = performance.now();
                    break;
            }
            draw();
            updateUI();
        });

        document.getElementById('start-btn').addEventListener('click', startGame);

        // Initial draw
        ctx.fillStyle = '#0a0a0f';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        nextCtx.fillStyle = '#11111a';
        nextCtx.fillRect(0, 0, 120, 120);
    </script>
</body>

</html>